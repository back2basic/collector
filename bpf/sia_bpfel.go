// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64 || wasm

package bpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type SiaIn6Addr struct {
	_    structs.HostLayout
	In6U struct {
		_       structs.HostLayout
		U6Addr8 [16]uint8
	}
}

type SiaSiaIpStats struct {
	_           structs.HostLayout
	Up9981      uint64
	Down9981    uint64
	Up9984Tcp   uint64
	Down9984Tcp uint64
	Up9984Udp   uint64
	Down9984Udp uint64
}

// LoadSia returns the embedded CollectionSpec for Sia.
func LoadSia() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_SiaBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load Sia: %w", err)
	}

	return spec, err
}

// LoadSiaObjects loads Sia and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*SiaObjects
//	*SiaPrograms
//	*SiaMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadSiaObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadSia()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// SiaSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type SiaSpecs struct {
	SiaProgramSpecs
	SiaMapSpecs
	SiaVariableSpecs
}

// SiaProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type SiaProgramSpecs struct {
	TcEgress *ebpf.ProgramSpec `ebpf:"tc_egress"`
	XdpProg  *ebpf.ProgramSpec `ebpf:"xdp_prog"`
}

// SiaMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type SiaMapSpecs struct {
	HostIpv4     *ebpf.MapSpec `ebpf:"host_ipv4"`
	HostIpv6     *ebpf.MapSpec `ebpf:"host_ipv6"`
	Ip4BytesDown *ebpf.MapSpec `ebpf:"ip4_bytes_down"`
	Ip4BytesUp   *ebpf.MapSpec `ebpf:"ip4_bytes_up"`
	Ip6BytesDown *ebpf.MapSpec `ebpf:"ip6_bytes_down"`
	Ip6BytesUp   *ebpf.MapSpec `ebpf:"ip6_bytes_up"`
	TcDebug      *ebpf.MapSpec `ebpf:"tc_debug"`
	TcLastIp     *ebpf.MapSpec `ebpf:"tc_last_ip"`
}

// SiaVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type SiaVariableSpecs struct {
}

// SiaObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadSiaObjects or ebpf.CollectionSpec.LoadAndAssign.
type SiaObjects struct {
	SiaPrograms
	SiaMaps
	SiaVariables
}

func (o *SiaObjects) Close() error {
	return _SiaClose(
		&o.SiaPrograms,
		&o.SiaMaps,
	)
}

// SiaMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadSiaObjects or ebpf.CollectionSpec.LoadAndAssign.
type SiaMaps struct {
	HostIpv4     *ebpf.Map `ebpf:"host_ipv4"`
	HostIpv6     *ebpf.Map `ebpf:"host_ipv6"`
	Ip4BytesDown *ebpf.Map `ebpf:"ip4_bytes_down"`
	Ip4BytesUp   *ebpf.Map `ebpf:"ip4_bytes_up"`
	Ip6BytesDown *ebpf.Map `ebpf:"ip6_bytes_down"`
	Ip6BytesUp   *ebpf.Map `ebpf:"ip6_bytes_up"`
	TcDebug      *ebpf.Map `ebpf:"tc_debug"`
	TcLastIp     *ebpf.Map `ebpf:"tc_last_ip"`
}

func (m *SiaMaps) Close() error {
	return _SiaClose(
		m.HostIpv4,
		m.HostIpv6,
		m.Ip4BytesDown,
		m.Ip4BytesUp,
		m.Ip6BytesDown,
		m.Ip6BytesUp,
		m.TcDebug,
		m.TcLastIp,
	)
}

// SiaVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadSiaObjects or ebpf.CollectionSpec.LoadAndAssign.
type SiaVariables struct {
}

// SiaPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadSiaObjects or ebpf.CollectionSpec.LoadAndAssign.
type SiaPrograms struct {
	TcEgress *ebpf.Program `ebpf:"tc_egress"`
	XdpProg  *ebpf.Program `ebpf:"xdp_prog"`
}

func (p *SiaPrograms) Close() error {
	return _SiaClose(
		p.TcEgress,
		p.XdpProg,
	)
}

func _SiaClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed sia_bpfel.o
var _SiaBytes []byte
